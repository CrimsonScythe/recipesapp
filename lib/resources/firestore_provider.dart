import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_facebook_login/flutter_facebook_login.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:recipes/src/models/favourite.dart';
import 'package:recipes/src/models/recipe.dart';
import 'package:recipes/src/models/user.dart';
import '../src/constants.dart' as Constants;
import 'package:intl/intl.dart';


class FirestoreProvider{
  Firestore _firestore = Firestore.instance;
  FirebaseAuth _firebaseAuth = FirebaseAuth.instance;
  GoogleSignIn _googleSignIn = GoogleSignIn();

  static final DateFormat formatter = DateFormat('yyyy-MM-dd');
  final String today = formatter.format(DateTime.now());

  Future<QuerySnapshot> getDailyRecipes() {
    return _firestore.collection('recipes').document(Constants.MEAT_DOC).collection(today).getDocuments();
  }


  Future<FirebaseUser> getUser() =>
      _firebaseAuth.currentUser();

  Future<void> addUser(User user) {

    return _firestore.collection("users").document(user.uID)
        .setData(user.toJson());
  }

  Future<void> logOut() {
    _firebaseAuth.signOut();
  }

  /// add recipereference and ctime to db
  Future<void> setFavourite(uID, recipeID) async {

    /// autogenerated document since there is no ned to explicitly query
    _firestore.collection("users").document(uID).collection("favourites")
        .document().setData(Favourite(recipeID, Timestamp.now()).toJson());

  }

  Future<void> deleteFavourite(uID, recipeID) async {
    /// query document using the recipeid.
    /// then delete the document
    print('recipeID');
    print(recipeID);
    final querySnap = await _firestore.collection("users").document(uID).collection("favourites")
        .where('reciperef', isEqualTo: recipeID).getDocuments();
    final docID = querySnap.documents[0].documentID;
    await _firestore.collection("users").document(uID).collection("favourites").document(docID).delete();

  }

  /// retrieve recipes ref from db and query db to get resulting recipes
  /// returns list<Recipe>
  Future<List<Recipe>> getFavourites(uID) async {

    List<Recipe> recipesList = List<Recipe>();
    /// recipeID contains doc refrerence to recipe
    /// order by ctime
    final querySnaps = await _firestore.collection("users").document(uID).collection("favourites").orderBy('ctime', descending: true)
        .getDocuments();

//    final path = querySnaps.documents[0].data['reciperef'].toString().split('/');
    for (int i=0; i < querySnaps.documents.length; i++) {
      final path = querySnaps.documents[i].data['reciperef'];
      final docSnap = await _firestore.document(path).get();
      recipesList.add(Recipe.fromJson(docSnap.data));
    }

    return recipesList;
//    await _firestore.collection(path[0]).document(path[1]).collection(path[2]).document(path[3])
//    .ge;


  }

  Future<User> logInAnon() async {

    AuthResult authResult = await _firebaseAuth.signInAnonymously();
    FirebaseUser user = authResult.user;
    /// if user is deleted from console
    if (user.getIdToken() == null) {
      await _firebaseAuth.signOut();
      authResult = await _firebaseAuth.signInAnonymously();
      user = authResult.user;
    }
    assert (user != null);
    assert (user.getIdToken() != null);
    return User(user.uid, '', Timestamp.now(), '');

  }

  Future<User> logInWithGoogle() async {

    final GoogleSignInAccount googleUser = await _googleSignIn.signIn();

    final GoogleSignInAuthentication googleAuth = await googleUser.authentication;

    final AuthCredential credential = GoogleAuthProvider.getCredential(
        idToken: googleAuth.idToken,
        accessToken: googleAuth.accessToken
    );

    final FirebaseUser user = (await _firebaseAuth.signInWithCredential(credential)).user;

    assert(user != null);
    assert(user.email != null);
    assert(user.displayName != null);
    assert(!user.isAnonymous);
    assert(await user.getIdToken() != null);

    final FirebaseUser currentUser = await _firebaseAuth.currentUser();
    assert(user.uid == currentUser.uid);

    //TODO: Please recheck assertions

    /**
     * Assertions work, so fill DB with userID
     */



    return User(user.uid, user.displayName, Timestamp.now(), user.photoUrl);


  }

  Future<User> logInWithFacebook() async {

    FacebookLogin facebookLogin = FacebookLogin();
    FacebookLoginResult facebookLoginResult = await facebookLogin.logIn(['email']);

    switch (facebookLoginResult.status) {
      case FacebookLoginStatus.cancelledByUser:
        print('cancelled');
        break;
      case FacebookLoginStatus.error:
        print('error');
        break;
      case FacebookLoginStatus.loggedIn:
        print('loggedin');
        break;
    }

    final token = facebookLoginResult.accessToken.token;

    assert (facebookLoginResult.status == FacebookLoginStatus.loggedIn);


      final facebookAuthCred = FacebookAuthProvider.getCredential(accessToken: token);

      final FirebaseUser user =
          (await _firebaseAuth.signInWithCredential(facebookAuthCred)).user;

      assert(user.email != null);
      assert(user.email != null);
      assert(user.displayName != null);
      assert(!user.isAnonymous);
      assert(await user.getIdToken() != null);

      final FirebaseUser currentUser = await _firebaseAuth.currentUser();
      assert(user.uid == currentUser.uid);

      //TODO: Please recheck assertions

      /**
       * Assertions work, so fill DB with userID
       */

    return User(user.uid, user.displayName, Timestamp.now(), user.photoUrl);


  }


}